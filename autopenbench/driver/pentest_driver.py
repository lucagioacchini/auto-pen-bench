from autopenbench.tools import wait_for_message
from autopenbench.shell import RemoteShell
import paramiko
import time
import subprocess
import os
import json
from dotenv import load_dotenv

load_dotenv()

# Set environment variables for project and scripts directories
PROJECT = os.environ.get("AUTOPENBENCH")
SCRIPTS = os.environ.get("KALISCRIPTS")


def restart_docker_compose_service(service_name: str):
    """Restarts a specific Docker Compose service and its dependencies.

    Args:
        service_name (str): The name of the Docker Compose service to restart.
    """
    # Save the current working directory and change to the project directory
    current_dir = str(os.path.abspath(os.curdir))
    os.chdir(PROJECT)

    # Parse the service name to identify its level, category, and VM
    split = service_name.split('_')
    level, vm = split[0], split[-1]
    category = '_'.join(split[1:-1])

    # Remove all files in the script directory except the 'leave_me_here' marker
    for file in os.listdir(SCRIPTS):
        if file != 'leave_me_here':
            os.system(f'rm {SCRIPTS}/{file}')
    os.chdir('../')
    # Retrieve docker-compose.yml paths
    with open('data/games.json', 'r') as file:
        data = json.loads(file.read())

    composes = []
    for comp_level in data:
        for comp_category in data[comp_level]:
            composes.append(
                f'benchmark/machines/{comp_level}/{comp_category}/docker-compose.yml')

    # Stop and remove Docker containers, and clean up orphaned containers
    commands = ["docker-compose", "-f",
                "benchmark/machines/docker-compose.yml",]
    for compose in composes:
        commands += ["-f", compose]
    commands += ["down", "--remove-orphans"]

    subprocess.run(commands, check=True)

    # Stop and remove Docker containers, and clean up orphaned containers
    commands = ["docker-compose", "-f",
                "benchmark/machines/docker-compose.yml",]
    for compose in composes:
        commands += ["-f", compose]
    commands += ["up", "-d", "kali_master"]

    # Start the base Kali container
    subprocess.run(commands, check=True)

    # Start the requested service
    subprocess.run(
        [
            "docker-compose", "-f", "benchmark/machines/docker-compose.yml",
            "-f", f"benchmark/machines/{level}/{category}/docker-compose.yml",
            "up", "-d", service_name
        ],
        check=True
    )

    # Handle special cases for additional services based on the VM name
    if service_name == 'in-vitro_web_security_vm3':
        subprocess.run(
            [
                "docker-compose", "-f", "benchmark/machines/docker-compose.yml",
                "-f", f"benchmark/machines/{level}/{category}/docker-compose.yml",
                "up", "-d", "in-vitro_web_security_vm3_database"
            ],
            check=True
        )
    elif service_name == 'in-vitro_web_security_vm4':
        subprocess.run(
            [
                "docker-compose", "-f", "benchmark/machines/docker-compose.yml",
                "-f", f"benchmark/machines/{level}/{category}/docker-compose.yml",
                "up", "-d", "in-vitro_web_security_vm4_database"
            ],
            check=True
        )
    elif service_name == 'in-vitro_network_security_vm5':
        subprocess.run(
            [
                "docker-compose", "-f", "benchmark/machines/docker-compose.yml",
                "-f", f"benchmark/machines/{level}/{category}/docker-compose.yml",
                "up", "-d", "in-vitro_network_security_vm5b"
            ],
            check=True
        )

    # Return to the original directory
    os.chdir(current_dir)



class PentestDriver():
    """Manages the pentesting workflow, including container management,
    SSH connections, and task execution.

    Args:
        task (str): The pentesting task being executed.
        flag (str): The flag to check during the pentest.
        target (str): The target Docker Compose service or machine.

    Attributes:
        task (str): Stores the pentesting task.
        flag (str): Stores the flag value.
        target (str): Stores the target service or machine name.
        ssh_kali (paramiko.SSHClient): SSH client to Kali machine.
        remotes (dict): Holds RemoteShell instances for remote machines.

    Methods:
        start_containers(): Starts or restarts Docker containers.
        _connect_to_kali(): Connects to the Kali master machine via SSH.
        reset(): Resets the environment by restarting containers and connecting to Kali.
    """

    def __init__(self, task: str, flag: str, target: str):
            self.task = task  # The task being executed
            self.flag = flag  # The flag to check for success
            self.target = target  # The target Docker Compose service or machine
            self.ssh_kali = None  # SSH connection to Kali machine
            self.remotes = {}  # Stores active remote shells

    def start_containers(self):
        """Restarts the target containers for the pentest.
        """
        restart_docker_compose_service(self.target)

    def _connect_to_kali(self):
        """Establishes an SSH connection to the Kali master machine.

        Returns:
            paramiko.SSHClient: The SSH client connected to the Kali machine.
        """
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(
            '192.168.0.5',
            username='root',
            password='root',
            port=22
        )

        return ssh

    def reset(self):
        """Resets the pentesting environment by restarting containers and 
        connecting to the Kali machine.

        Returns:
            tuple: The current task and a boolean indicating whether the 
            pentest is complete.
        """
        self.start_containers()

        # Connect to Kali
        self.ssh_kali = self._connect_to_kali()
        shell = self.ssh_kali.invoke_shell()
        wait_for_message(shell)  # Wait for the initial prompt from the shell
        # Store the remote shell
        self.remotes['192.168.0.5'] = RemoteShell(shell)

        # Handle specific target-related delays (for real-world machines)
        if self.target in ['real-world_cve_vm6', 'real-world_cve_vm7']:
            print('Starting the service. Please wait...')
            time.sleep(20)

        return self.task, False