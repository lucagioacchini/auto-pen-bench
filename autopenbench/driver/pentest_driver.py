import mcp.types as types
from mcp.server.fastmcp import FastMCP
from pydantic import Field
from autopenbench.tools import wait_for_message, SSHConnect, ExecuteBash, WriteFile
from autopenbench.shell import RemoteShell
import paramiko
import time
import subprocess
import os
import json
from dotenv import load_dotenv

load_dotenv()

# Set environment variables for project and scripts directories
PROJECT = os.environ.get("AUTOPENBENCH")
SCRIPTS = os.environ.get("KALISCRIPTS")


def restart_docker_compose_service(service_name: str):
    """Restarts a specific Docker Compose service and its dependencies.

    Args:
        service_name (str): The name of the Docker Compose service to restart.
    """
    # Save the current working directory and change to the project directory
    current_dir = str(os.path.abspath(os.curdir))
    os.chdir(PROJECT)

    # Parse the service name to identify its level, category, and VM
    split = service_name.split('_')
    level, vm = split[0], split[-1]
    category = '_'.join(split[1:-1])

    # Remove all files in the script directory except the 'leave_me_here' marker
    for file in os.listdir(SCRIPTS):
        if file != 'leave_me_here':
            os.system(f'rm {SCRIPTS}/{file}')
    os.chdir('../')
    # Retrieve docker-compose.yml paths
    with open('data/games.json', 'r') as file:
        data = json.loads(file.read())

    composes = []
    for comp_level in data:
        for comp_category in data[comp_level]:
            composes.append(
                f'benchmark/machines/{comp_level}/{comp_category}/docker-compose.yml')

    # Stop and remove Docker containers, and clean up orphaned containers
    commands = ["docker-compose", "-f",
                "benchmark/machines/docker-compose.yml",]
    for compose in composes:
        commands += ["-f", compose]
    commands += ["down", "--remove-orphans"]

    subprocess.run(commands, check=True)

    # Stop and remove Docker containers, and clean up orphaned containers
    commands = ["docker-compose", "-f",
                "benchmark/machines/docker-compose.yml",]
    for compose in composes:
        commands += ["-f", compose]
    commands += ["up", "-d", "kali_master"]

    # Start the base Kali container
    subprocess.run(commands, check=True)

    # Start the requested service
    subprocess.run(
        [
            "docker-compose", "-f", "benchmark/machines/docker-compose.yml",
            "-f", f"benchmark/machines/{level}/{category}/docker-compose.yml",
            "up", "-d", service_name
        ],
        check=True
    )

    # Handle special cases for additional services based on the VM name
    if service_name == 'in-vitro_web_security_vm3':
        subprocess.run(
            [
                "docker-compose", "-f", "benchmark/machines/docker-compose.yml",
                "-f", f"benchmark/machines/{level}/{category}/docker-compose.yml",
                "up", "-d", "in-vitro_web_security_vm3_database"
            ],
            check=True
        )
    elif service_name == 'in-vitro_web_security_vm4':
        subprocess.run(
            [
                "docker-compose", "-f", "benchmark/machines/docker-compose.yml",
                "-f", f"benchmark/machines/{level}/{category}/docker-compose.yml",
                "up", "-d", "in-vitro_web_security_vm4_database"
            ],
            check=True
        )
    elif service_name == 'in-vitro_network_security_vm5':
        subprocess.run(
            [
                "docker-compose", "-f", "benchmark/machines/docker-compose.yml",
                "-f", f"benchmark/machines/{level}/{category}/docker-compose.yml",
                "up", "-d", "in-vitro_network_security_vm5b"
            ],
            check=True
        )

    # Return to the original directory
    os.chdir(current_dir)


def create_mcp_server() -> FastMCP:
    mcp: FastMCP = FastMCP("pentest_driver", dependencies=["pydantic"])
    
    # Global instance to maintain state - you'll need to initialize this somehow
    pentest_driver = None

    @mcp.tool(description="Execute a shell command on a machine")
    async def execute_bash(
        machine_ipaddr: str = Field(..., description="IP address of the target machine"),
        cmd: str = Field(..., description="Bash command to execute")
    ) -> list[types.TextContent]:
        """Execute a shell command on a machine."""
        if pentest_driver is None:
            return [types.TextContent(type="text", text="Error: No pentest session initialized.")]
        
        if machine_ipaddr in pentest_driver.remotes:
            shell = pentest_driver.remotes[machine_ipaddr]
            out = ExecuteBash(machine_ipaddr=machine_ipaddr, cmd=cmd).run(shell)
        else:
            # Handle Kali reconnection logic
            if machine_ipaddr == '192.168.0.5':
                print('Restarting kali connection')
                pentest_driver.ssh_kali = pentest_driver._connect_to_kali()
                shell = pentest_driver.ssh_kali.invoke_shell()
                wait_for_message(shell)
                pentest_driver.remotes['192.168.0.5'] = RemoteShell(shell)
                shell = pentest_driver.remotes[machine_ipaddr]
                out = ExecuteBash(machine_ipaddr=machine_ipaddr, cmd=cmd).run(shell)
            else:
                out = 'Before sending a remote command you need to set-up an SSH connection.'
        
        return [types.TextContent(type="text", text=out)]

    @mcp.tool(description="Establish SSH connection to a remote machine")
    async def ssh_connect(
        ssh_ipaddr: str = Field(..., description="Remote server IP address"),
        ssh_port: int = Field(..., description="SSH port number"),
        ssh_username: str = Field(..., description="SSH username"),
        ssh_password: str = Field(..., description="SSH password")
    ) -> list[types.TextContent]:
        """Start an SSH session into the target machine"""
        if pentest_driver is None:
            return [types.TextContent(type="text", text="Error: No pentest session initialized.")]
        
        try:
            ssh, out = SSHConnect(
                ssh_ipaddr=ssh_ipaddr,
                ssh_port=ssh_port,
                ssh_username=ssh_username,
                ssh_password=ssh_password
            ).run(pentest_driver.ssh_kali)
            
            pentest_driver.remotes[ssh_ipaddr] = RemoteShell(ssh)
            return [types.TextContent(type="text", text=out)]
        except Exception as e:
            return [types.TextContent(type="text", text=f"SSH connection failed: {str(e)}")]

    @mcp.tool(description="Submit the final answer flag")
    async def final_answer(
        flag: str = Field(..., description="The captured flag")
    ) -> list[types.TextContent]:
        """Provide the final flag of the CTF game."""
        # Logic handled client side - this is just to let the agent know the tool exists
        return [types.TextContent(type="text", text=f"Final answer submitted: {flag}")]

    @mcp.tool(description="Write content to a file")
    async def write_file(
        content: str = Field(..., description="Content to write to the file"),
        file_name: str = Field(..., description="Name of the file to create")
    ) -> list[types.TextContent]:
        """Write a script or a text into a file. The file will be located in the /root/scripts folder of Kali machine."""
        if pentest_driver is None:
            return [types.TextContent(type="text", text="Error: No pentest session initialized.")]
        
        out = WriteFile(content=content, file_name=file_name).run()
        return [types.TextContent(type="text", text=out)]

    return mcp


class PentestDriver():
    """Manages the pentesting workflow, including container management,
    SSH connections, and task execution.

    Args:
        task (str): The pentesting task being executed.
        flag (str): The flag to check during the pentest.
        target (str): The target Docker Compose service or machine.

    Attributes:
        task (str): Stores the pentesting task.
        flag (str): Stores the flag value.
        target (str): Stores the target service or machine name.
        ssh_kali (paramiko.SSHClient): SSH client to Kali machine.
        remotes (dict): Holds RemoteShell instances for remote machines.

    Methods:
        start_containers(): Starts or restarts Docker containers.
        _connect_to_kali(): Connects to the Kali master machine via SSH.
        reset(): Resets the environment by restarting containers and connecting to Kali.
    """

    def __init__(self, task: str, flag: str, target: str):
        self.task = task  # The task being executed
        self.flag = flag  # The flag to check for success
        self.target = target  # The target Docker Compose service or machine
        self.ssh_kali = None  # SSH connection to Kali machine
        self.remotes = {}  # Stores active remote shells

    def start_containers(self):
        """Restarts the target containers for the pentest.
        """
        restart_docker_compose_service(self.target)

    def _connect_to_kali(self):
        """Establishes an SSH connection to the Kali master machine.

        Returns:
            paramiko.SSHClient: The SSH client connected to the Kali machine.
        """
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(
            '192.168.0.5',
            username='root',
            password='root',
            port=22
        )

        return ssh

    def reset(self):
        """Resets the pentesting environment by restarting containers and 
        connecting to the Kali machine.

        Returns:
            tuple: The current task and a boolean indicating whether the 
            pentest is complete.
        """
        self.start_containers()

        # Connect to Kali
        self.ssh_kali = self._connect_to_kali()
        shell = self.ssh_kali.invoke_shell()
        wait_for_message(shell)  # Wait for the initial prompt from the shell
        # Store the remote shell
        self.remotes['192.168.0.5'] = RemoteShell(shell)

        # Handle specific target-related delays (for real-world machines)
        if self.target in ['real-world_cve_vm6', 'real-world_cve_vm7']:
            print('Starting the service. Please wait...')
            time.sleep(20)

        return self.task, False


def main() -> None:
    print("Starting Pentest Driver MCP Server")
    mcp = create_mcp_server()
    mcp.run(transport="stdio")


if __name__ == "__main__":
    main()